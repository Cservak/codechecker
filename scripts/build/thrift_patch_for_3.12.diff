--- a/transport/THttpClient.py
+++ b/transport/THttpClient.py
@@ -65,7 +65,45 @@ class THttpClient(TTransportBase):
                 self.port = parsed.port or http_client.HTTPS_PORT
                 self.certfile = cert_file
                 self.keyfile = key_file
-                self.context = ssl.create_default_context(cafile=cafile) if (cafile and not ssl_context) else ssl_context
+                # TODO: this is a hack that should be purged once Thrift's
+                # Python library correctly supports Python >=3.12 versions.
+                # Since from 3.12 the http.client.HTTPSConnection class'
+                # constructor does not support keyword argument 'key_file'
+                # and 'cert_file', we backport the logic here.
+                # The latest versions almost do the right thing, but the
+                # 'load_cert_chain' method is not called on the context object
+                # by default in the newer implementations. It is unclear
+                # whether CodeChecker's use of this THttpClient class would
+                # actually need this, but I think it is safer to have this
+                # called nevertheless to provide better parity with the original behaviour.
+                #
+                # old implementation of http.client.HTTPSConnection:
+                # https://github.com/python/cpython/blob/3.11/Lib/http/client.py#L1419
+                #
+                # new implementation of http.client.HTTPSConnection:
+                # https://github.com/python/cpython/blob/3.13/Lib/http/client.py#L1454
+                if cafile and not ssl_context:
+                    if not Path(cafile).is_file():
+                        raise ValueError("Invalid cafile path: '%s'" % (cafile))
+
+                    new_context = ssl.create_default_context(cafile=cafile)
+
+                    if ssl.HAS_ALPN:
+                        new_context.set_alpn_protocols(['http/1.1', 'h2'])
+
+                    if key_file:
+                        if not Path(cert_file).is_file():
+                            raise ValueError("Invalid cert_file path: '%s'" % (cert_file))
+                        if not Path(key_file).is_file():
+                            raise ValueError("Invalid key_file path: '%s'" % (key_file))
+                        try:
+                            new_context.load_cert_chain(cert_file, key_file)
+                        except ssl.SSLError as e:
+                            raise ValueError("Failed to load cert/key files: %s" % (e))
+
+                    self.context = new_context
+                else:
+                    self.context = ssl_context
             self.host = parsed.hostname
             self.path = parsed.path
             if parsed.query:
@@ -110,8 +148,6 @@ class THttpClient(TTransportBase):
                                                      timeout=self.__timeout)
         elif self.scheme == 'https':
             self.__http = http_client.HTTPSConnection(self.host, self.port,
-                                                      key_file=self.keyfile,
-                                                      cert_file=self.certfile,
                                                       timeout=self.__timeout,
                                                       context=self.context)
         if self.using_proxy():
